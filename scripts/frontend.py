#!/usr/bin/python3
import ctypes
import random
import sys

class BluespecREPL:

    def __init__(self, sofile):
        """ Init an repl based on the sofile and the rulefile specified, which are generated by the other scripts.
        """
        self.lib = ctypes.CDLL(sofile)
        # get all the rules
        num_rules = self.lib.get_num_rules()
        self.listrules = [''] * num_rules
        get_rule_fn = self.lib.get_rule
        get_rule_fn.restype = ctypes.c_char_p
        for i in range(num_rules):
            self.listrules[i] = get_rule_fn(i).decode('ascii')
        self.lib.construct()

    def __del__(self):
        self.lib.destruct()
        del self.lib

    def setfire(self, listToFire):
        """ This function set block fire signal to one for every rule that is not in the listToFire. """
        list_blocked = []
        for rule in listToFire:
            index = self.listrules.index(rule) 
            list_blocked += [index]
        for i in range(len(self.listrules)):
            if i not in list_blocked:
                self.lib.set_BLOCK_FIRE(i,1)
            else:
                self.lib.set_BLOCK_FIRE(i,0)
  
    def run_bsc(self,n, printRulesFired=False):
        """ Do n step of the code, with the scheduler created by Bluespec. """
        self.setfire(self.listrules)
        for i in range(n):
            self.step(printRulesFired=printRulesFired)

    def list_can_fire(self):
        """ list the rules with can_fire = 1 """
        list_can = []
        for i in range(len(self.listrules)):
            if self.lib.get_CAN_FIRE(i)==1:
                list_can += [self.listrules[i]]            
        return list_can
 
    def list_will_fire(self):
        """ list the rules that will fire """
        list_can = []
        for i in range(len(self.listrules)):
            if self.lib.get_WILL_FIRE(i)==1:
                list_can += [self.listrules[i]]            
        return list_can
                    
    def run_random_schedule(self,n,printRulesFired=False):
        """ Do n step where at each one of the rules that can fire is picked randomly """
        for i in range(n):
            choosen = random.choice(self.list_can_fire()) 
            if (printRulesFired):
                print(choosen)
            self.setfire([choosen])
            self.step(printRulesFired=printRulesFired)


    
    def step(self,printRulesFired=False):
        self.lib.eval()
        if (printRulesFired):
                print(self.list_will_fire())
        self.lib.set_CLK(1)
        self.lib.eval()
        self.lib.set_CLK(0)
        self.lib.eval()

    #A couple of low level wrappers, maybe we should get rid of them?
    def propagate(self):
        """ This function lift the combinational propagation without toggling the clocks"""
        self.lib.eval()
    
    def set_clk(self,val):
        self.lib.set_CLK(val)

    def get_clk(self):
        return self.lib.get_CLK()
     
