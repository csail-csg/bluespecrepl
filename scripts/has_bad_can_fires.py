#!/usr/bin/env python3

import sys
import re

"""
Due to common sub-expression elimination in the compiler, sometimes CAN_FIRE
signals get used in place of WILL_FIRE signals. Since we are modifying
WILL_FIRE signals in order to implement Bluespec REPL, we cannot work with
verilog files that use CAN_FIRE signals in the wrong places. To avoid this
issue, we compile designs with the -no-opt-ATS flag to prevent common sub-
expression elimination.

CAN_FIRE signals are expected in only 3 contexts:
    1) wire CAN_FIRE_*, ...
        All CAN_FIRE_* signals are expected in this context.
    2) assign CAN_FIRE_* = <expression>
        The initial CAN_FIRE signal is expected, but there should be no
        CAN_FIRE signals in <expression>.
    3) assign WILL_FIRE_<name> = <expression>.
        CAN_FIRE_<name> is expected in <expression> but there should be no
        other CAN_FIRE signals in <expression>.
If a CAN_FIRE signal appears in another context, it is the result of common
sub-expression elimination.

This file contains the function 'has_bad_can_fires' in order to detect if
CAN_FIRE signals are being used in place of other signals (such as WILL_FIRE).

Originally our approach was to replace CAN_FIRE with their corresponding
WILL_FIRE where CAN_FIRE signals are unexpected, but this is insufficient
for more complicated designs (for example if two rules share the same non-
trivial guard). The old approach can be found in the function 'fix_can_fires'.
"""

def has_bad_can_fires(verilog_source):
    """
    Reports if the provided verilog source uses a CAN_FIRE signal in a context
    that doesn't make sense semantically.
    """
    blocks = verilog_source.split(';')
    converted_blocks = []
    for block in blocks:
        # context 1
        match = re.search(r'wire CAN_FIRE_.*', block, re.DOTALL)
        if match:
            # all CAN_FIRES are allowed in this context
            converted_blocks.append(block)
            continue
        # context 2
        match = re.search(r'assign CAN_FIRE_[$\w]*? =', block, re.DOTALL)
        if match:
            # only the initial CAN_FIRE is allowed in this context
            match = re.search(r'CAN_FIRE_[$\w]*', block[match.end():])
            if match:
                return True
            continue
        # context 3
        match = re.search(r'assign (RDY|WILL_FIRE)_([$\w]*?) =', block, re.DOTALL)
        if match:
            # only CAN_FIRE_x is allowed in this context (where x matches the
            # assigned WILL_FIRE_x)
            can_fires = re.findall(r'CAN_FIRE_([$\w]*)', block[match.end():])
            for x in can_fires:
                if x != match.group(2):
                    return True
            continue
        # not a special context
        # CAN_FIRE is not allowed
        match = re.search(r'CAN_FIRE_([$\w]*)', block)
        if match:
            return True
    return False

def fix_can_fires(verilog_source):
    """
    NOTE: This function doesn't work correctly for all possible verilog output
    generated by bsc. Instead you should use the -no-opt-ATS flag when compiling
    and use has_bad_can_fires to make sure -no-opt-ATS was used.
    """
    print('WARNING: fix_can_fires does not fix all CAN_FIRE signals correctly')
    blocks = verilog_source.split(';')
    converted_blocks = []
    for block in blocks:
        # context 1
        match = re.search(r'wire CAN_FIRE_.*', block, re.DOTALL)
        if match:
            # all CAN_FIRES are allowed in this context
            converted_blocks.append(block)
            continue
        # context 2
        match = re.search(r'assign CAN_FIRE_[$\w]*? =', block, re.DOTALL)
        if match:
            # only the initial CAN_FIRE is allowed in this context
            fixed_part_of_block = re.sub(r'CAN_FIRE_([$\w]*)',
                                        r'WILL_FIRE_\1',
                                        block[match.end():])
            new_block = block[0:match.end()] + fixed_part_of_block
            converted_blocks.append(new_block)
            continue
        # context 3
        match = re.search(r'assign WILL_FIRE_([$\w]*?) =', block, re.DOTALL)
        if match:
            # only CAN_FIRE_x is allowed in this context (where x matches the
            # assigned WILL_FIRE_x)
            # plan: all CAN_FIRE -> WILL_FIRE, then WILL_FIRE_x -> CAN_FIRE_x
            fixed_part_of_block = re.sub(r'CAN_FIRE_([$\w]*)',
                                        r'WILL_FIRE_\1',
                                        block[match.end():])
            fixed_part_of_block = re.sub(r'WILL_FIRE_%s' % match.group(1),
                                        r'CAN_FIRE_%s' % match.group(1),
                                        fixed_part_of_block)
            new_block = block[0:match.end()] + fixed_part_of_block
            converted_blocks.append(new_block)
            continue
        # not a special context
        new_block = re.sub(r'CAN_FIRE_([$\w]*)',
                        r'WILL_FIRE_\1',
                        block)
        converted_blocks.append(new_block)
    return ';'.join(converted_blocks)

def main():
    if len(sys.argv) == 1:
        print('ERROR: this program expects a bluespec-generated verilog file (with -keep-fires) as a command-line argument')
        sys.exit(1)
    else:
        with open(sys.argv[1], 'r') as f:
            verilog_source = f.read()
        bad_can_fires = has_bad_can_fires(verilog_source)
        if bad_can_fires:
            print('Bad CAN_FIRE signals found.')
            sys.exit(1)
        else:
            print('No bad CAN_FIRE signals found.')
            sys.exit(0)

if __name__ == '__main__':
    main()
